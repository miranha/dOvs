structure A = Absyn
structure S = Symbol

(* [these functions and similar ones may be convenient
 * for the creation of abstract syntax trees] *)

datatype lvaluePartSpec = Field of S.symbol
                        | Subscript of A.exp

fun makeLvaluePartSpec (v, pos, l::r) =
  (case l
    of Field idsym =>
       makeLvaluePartSpec (A.FieldVar (v, idsym, pos), pos, r)
     | Subscript exp =>
       makeLvaluePartSpec (A.SubscriptVar (v, exp, pos), pos,r))
  | makeLvaluePartSpec (v, _, nil) = v

fun makeBinop (e1, bop, e2, p) =
    A.OpExp  { left = e1
             , oper = bop
             , right = e2
             , pos = p}

fun makeIf (et, en, el, p) =
    A.IfExp  { test = et
             , thn = en
             , els = el
             , pos = p}

fun makeVarDec (idsym, ty, e, p) =
    A.VarDec { name = idsym
             , escape = ref true
             , typ = ty
             , init = e
             , pos = p}

fun makeFundecl (idsym, ps, rty, e, p) =
             { name = idsym
             , params = ps
             , result = rty
             , body = e
             , pos = p} : A.fundecldata

%%
%term
    EOF
  | ID of string
  | INT of int | STRING of string
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK
  | LBRACE | RBRACE | DOT
  | PLUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE | CARET
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF
  | BREAK | NIL
  | FUNCTION | VAR | TYPE

(* [add missing nonterminals; in second phase: add semantic values] *)

%nonterm program | exp
  | dec 
  | tydec | vardec | fundec | fielddec
  | ty | typeid | tyfields
  | arrtype | recordtype
  (* Here we define certain non terminals to stand for expressions *)
  | lvalue | subscript
  | fieldexp
  | callexp
  | arrcreate
  | reccreate
  | fieldcreate
  | assignment
  | seqexp | seqsexps
  | letexp 
  | binop | unaryop
  | ifexp | ifelseexp
  | whileexp
  | forexp

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

(* Here we will esablish precedence for standard Arithmetic expressions +,-,/,*,^ *)
%left PLUS MINUS
%left TIMES DIVIDE
%right CARET



%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION
         VAR TYPE ARRAY IF THEN ELSE DO OF NIL

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

(* [specify precedence/associativity, least tight binding first] *)

%nonassoc   FUNCTION VAR TYPE THEN DO OF ASSIGN
%right      ELSE
(* [..more tokens & levels..] *)

%%

(* Top level constructs *)

program: exp                  ()

exp: INT       ()
  | STRING ()
  | NIL ()
  | BREAK ()
  | seqexp ()
  | unaryop  ()
  | binop                   ()
  | callexp ()
  | assignment ()
  | forexp ()
  | whileexp ()
  | ifexp ()
  | ifelseexp ()

binop : exp PLUS	exp 	%prec PLUS ()
		 | exp MINUS exp 	%prec MINUS ()
		 | exp TIMES exp 	%prec TIMES ()
		 | exp DIVIDE exp 	%prec DIVIDE ()
		 | exp CARET exp 	%prec CARET ()

unaryop : MINUS exp ()

seqexp : LPAREN seqsexps RPAREN ()

seqsexps : exp ()
        | exp SEMICOLON seqsexps ()

callexp : ID LPAREN RPAREN ()

assignment : ID COLON EQ exp ()

forexp : FOR ID COLON EQ exp TO exp DO exp ()

whileexp : WHILE exp DO exp ()

ifexp : IF exp THEN exp ()

ifelseexp : IF exp THEN exp ELSE exp ()

    (* [..missing rules for exp..] *)

(* [..missing rules for missing nonterminals..] *)
