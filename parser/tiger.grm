structure A = Absyn
structure S = Symbol

(* [these functions and similar ones may be convenient
 * for the creation of abstract syntax trees] *)

datatype lvaluePartSpec = Field of S.symbol
                        | Subscript of A.exp

fun makeInt(e)=A.IntExp e

fun makeLvaluePartSpec (v, pos, l::r) =
  (case l
    of Field idsym =>
       makeLvaluePartSpec (A.FieldVar (v, idsym, pos), pos, r)
     | Subscript exp =>
       makeLvaluePartSpec (A.SubscriptVar (v, exp, pos), pos,r))
  | makeLvaluePartSpec (v, _, nil) = v

fun makeBinop (e1, bop, e2, p) =
    A.OpExp  { left = e1
             , oper = bop
             , right = e2
             , pos = p}

fun makeIf (et, en, el, p) =
    A.IfExp  { test = et
             , thn = en
             , els = el
             , pos = p}

fun makeVarDec (idsym, ty, e, p) =
    A.VarDec { name = idsym
             , escape = ref true
             , typ = ty
             , init = e
             , pos = p}

fun makeFundecl (idsym, ps, rty, e, p) =
             { name = idsym
             , params = ps
             , result = rty
             , body = e
             , pos = p} : A.fundecldata

%%
%term
    EOF
  | ID of string
  | INT of int | STRING of string
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK
  | LBRACE | RBRACE | DOT
  | PLUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE | CARET
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF
  | BREAK | NIL
  | FUNCTION | VAR | TYPE

(* [add missing nonterminals; in second phase: add semantic values] *)

%nonterm program of A.exp | exp of A.exp
(*  | dec of A.exp
  | tydec of A.exp | vardec of A.exp | fundec of A.exp | fielddec of A.exp | fielddeccontent of A.exp
  | ty of A.exp | typeid of A.exp | tyfields of A.exp
  | arrty of A.exp | recty of A.exp
  (* Here we define certain non terminals to stand for expressions *)
  | lvalue of A.exp | subscript of A.exp
  | fieldexp of A.exp
  | callexp of A.exp | callexpcon of A.exp
  | arrcreate of A.exp
  | reccreate of A.exp | reccreatecon of A.exp
  | fieldcreate of A.exp
  | assignment of A.exp
  | seqexp of A.exp | seqsexps of A.exp
  | letexp of A.exp | deccon of A.exp
  | binop of A.exp | unaryop of A.exp
  | ifexp of A.exp | ifelseexp of A.exp
  | whileexp of A.exp
  | forexp of A.exp *)



(* Here we will esablish precedence for standard Arithmetic expressions +,-,/,*,^ *)
%left PLUS MINUS
%left TIMES DIVIDE
%right CARET

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION
         VAR TYPE ARRAY IF THEN ELSE DO OF NIL

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

(* [specify precedence/associativity, least tight binding first] *)

%nonassoc   FUNCTION VAR TYPE THEN DO OF ASSIGN
%right      ELSE
(* [..more tokens & levels..] *)

%pos int
%verbose
%start program
%eop EOF
%noshift EOF


%%

(* Top level constructs *)

program: exp                  (exp)

exp: INT       ( A.IntExp INT)
(*  | STRING ()
  | NIL ()
  | BREAK ()
  | seqexp ()
  | unaryop  ()
  | binop  ()
  | callexp ()
  | assignment ()
  | forexp ()
  | whileexp ()
  | ifexp ()
  | ifelseexp ()
  | lvalue ()
  | arrcreate ()
  | reccreate ()
  | letexp ()

binop : exp PLUS	exp 	%prec PLUS ()
		 | exp MINUS exp 	%prec MINUS ()
		 | exp TIMES exp 	%prec TIMES ()
		 | exp DIVIDE exp 	%prec DIVIDE ()
		 | exp CARET exp 	%prec CARET ()

unaryop : MINUS exp ()

seqexp : LPAREN seqsexps RPAREN ()

seqsexps : exp ()
        | exp SEMICOLON seqsexps ()
        | ()

callexp : ID LPAREN callexpcon RPAREN ()

callexpcon : exp ()
			| exp COMMA callexpcon ()
			| ()

assignment : ID ASSIGN exp ()

forexp : FOR ID ASSIGN exp TO exp DO exp ()

whileexp : WHILE exp DO exp ()

ifexp : IF exp THEN exp ()

ifelseexp : IF exp THEN exp ELSE exp ()

tydec : TYPE ID	EQ ty ()

ty : ID ()
	| arrty ()
	| recty ()

arrty : ARRAY OF ID ()

recty : LBRACE fielddeccontent RBRACE ()

fielddeccontent : fielddec ()
				| fielddec COMMA fielddeccontent ()
				| ()


fielddec : ID COLON ID ()

fundec : ID LPAREN fielddeccontent RPAREN EQ exp ()
		| ID LPAREN fielddeccontent RPAREN COLON ID EQ exp ()

vardec : ID ASSIGN exp ()
		| ID COLON ID ASSIGN exp ()

lvalue : ID ()
		| subscript ()
		| fieldexp ()

subscript : lvalue LBRACK exp RBRACK ()

fieldexp : lvalue DOT ID ()

arrcreate : ID LBRACK exp RBRACK OF exp ()

reccreate : ID LBRACE reccreatecon RBRACE ()

reccreatecon : fieldcreate ()
			| fieldcreate COMMA reccreatecon ()
			| ()

fieldcreate : ID EQ exp ()

letexp : LET deccon IN seqsexps END ()

deccon : dec ()
		| dec deccon ()

dec : tydec ()
    | vardec ()
    | fundec ()

*)
    (* [..missing rules for exp..] *)

(* [..missing rules for missing nonterminals..] *)
