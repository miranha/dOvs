structure A = Absyn
structure S = Symbol

(* [these functions and similar ones may be convenient
 * for the creation of abstract syntax trees] *)

datatype lvalueSpec = Field of S.symbol
		| Subscript of A.exp

fun makeInt(e)=A.IntExp e

fun makeCallExp( f , arglist, p) =
 A.CallExp { func = S.symbol f, 
	      args = arglist, 
	      pos = p}
(* have to wait until we resolve lvalue
fun makeAssignExp (id, expr, p) =
A.AssignExp{ var = _, exp = expr, pos = p}
*)

fun makeLvalue (v, p, (value,pos)::l) = (case value of
					   Field(s) => makeLvalue(A.FieldVar(v, s , pos), pos, l)
						  | Subscript(exp) => makeLvalue(A.SubscriptVar(v,exp,pos), pos, l)
)
				       |  makeLvalue (v,_,[]) = v

(* check if we have var expression, extract the
underlying variable *)
fun getLvalue ( var : A.exp) : A.var = 
  (case var of A.VarExp(v) => v
	    | _  => A.SimpleVar(S.symbol "bogusVar", 0))
  
fun makeBinop (e1, bop, e2, p) =
    A.OpExp  { left = e1
             , oper = bop
             , right = e2
             , pos = p}

fun makeIf (et, en, el, p) =
    A.IfExp  { test = et
             , thn = en
             , els = el
             , pos = p}

fun makeVarDec (idsym, ty, e, p) =
    A.VarDec { name = idsym
             , escape = ref true
             , typ = ty
             , init = e
             , pos = p}

fun makeAssign (v, e, p) =
  A.AssignExp { var = v
	      , exp = e
	      , pos = p }

fun makeWhile (t, e, p) =
  A.WhileExp { test = t
	   , body = e
	   , pos = p }

fun makeFor (i, low, high, e, p) =
  let val s = (S.symbol i) in
  A.ForExp { var = s
	   , escape = ref true
	   , lo = low
	   , hi = high
	   , body = e
	   , pos = p }
  end
				
fun makeFundecl (idsym, ps, rty, e, p) =
             { name = idsym
             , params = ps
             , result = rty
             , body = e
             , pos = p} : A.fundecldata


%%
%term
    EOF
  | ID of string
  | INT of int | STRING of string
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK
  | LBRACE | RBRACE | DOT
  | PLUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE | CARET
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF
  | BREAK | NIL
  | FUNCTION | VAR | TYPE

(* [add missing nonterminals; in second phase: add semantic values] *)

%nonterm program of A.exp | exp of A.exp
  | dec of A.exp
  | tydec of A.exp | vardec of A.exp | fundec of A.exp | fielddec of A.exp | fielddeccontent of A.exp
  | ty of A.exp | typeid of A.exp | tyfields of A.exp
  | arrty of A.exp | recty of A.exp
  (* Here we define certain non terminals to stand for expressions *) 
  | lvalue of A.exp  
  | subscript of (lvalueSpec * int)
  | fieldexp of (lvalueSpec * int)
  | ltail of (lvalueSpec * int) list
  | callexp of A.exp | callexpcon of (A.exp * A.pos) list
  | arrcreate of A.exp
  | reccreate of A.exp | reccreatecon of A.exp
  | fieldcreate of A.exp
  | assignment of A.exp
  | seqexp of A.exp | seqsexps of (A.exp * int) list
  | letexp of A.exp | deccon of A.exp
  | binop of A.exp | unaryop of A.exp
  | ifexp of A.exp | ifelseexp of A.exp
  | whileexp of A.exp
  | forexp of A.exp





%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION
         VAR TYPE ARRAY IF THEN ELSE DO OF NIL

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

(* [specify precedence/associativity, least tight binding first] *)

(* Here we will esablish precedence for standard operators including +,-,/,*,^ *)
%left OR
%left AND
%nonassoc EQ NEQ LT LE GT GE
%left PLUS MINUS
%left TIMES DIVIDE
%right CARET
%right ID
%right ELSE
(* [..more tokens & levels..] *)

%nonassoc FUNCTION VAR TYPE THEN DO OF ASSIGN 

%pos int
%verbose
%start program
%eop EOF
%noshift EOF


%%

(* Top level constructs *)

program: exp                  (exp)

exp: INT       ( A.IntExp INT)
   | STRING ( A.StringExp(STRING , STRING1left) )
  | NIL ( A.NilExp )
  | BREAK (A.BreakExp BREAK1left)
  | seqexp ( seqexp )
  | unaryop  (unaryop)
  | binop  (binop)
  | callexp (callexp)
  | assignment ( assignment )
  | lvalue (lvalue)
  | forexp ( forexp )
  | whileexp ( whileexp )
  | ifexp ( ifexp )
  | ifelseexp ( ifelseexp )
  | arrcreate ( A.IntExp(0) )
  | reccreate ( A.IntExp(0) )
  | letexp ( A.IntExp(0) )

binop : exp PLUS exp 	%prec PLUS ( makeBinop (exp1,A.PlusOp,exp2, PLUSleft ))
	| exp MINUS exp 	%prec MINUS (makeBinop (exp1,A.MinusOp,exp2, MINUSleft ))
	| exp TIMES exp 	%prec TIMES ( makeBinop( exp1, A.TimesOp, exp2, TIMESleft ))
	| exp DIVIDE exp 	%prec DIVIDE ( makeBinop(exp1, A.DivideOp, exp2, DIVIDEleft ))
	| exp CARET exp 	%prec CARET ( makeBinop( exp1, A.ExponentOp, exp2, CARETleft ))
(* logical operators here *)
	| exp AND exp %prec AND ( makeIf(exp1,exp2,SOME (A.IntExp(0)), ANDleft))
	| exp OR exp %prec OR ( makeIf (exp1, A.IntExp(1), SOME exp2, ORleft))
	| exp EQ exp %prec EQ (makeBinop(exp1,A.EqOp,exp2,EQleft))
	| exp NEQ exp %prec NEQ ( makeBinop(exp1,A.NeqOp,exp2,NEQleft) )
	| exp LT exp %prec LT ( makeBinop(exp1,A.LtOp,exp2,LTleft) )
	| exp LE exp %prec LE ( makeBinop(exp1,A.LeOp,exp2,LEleft) )
	| exp GT exp %prec GT ( makeBinop(exp1,A.GtOp,exp2,GTleft) )
	| exp GE exp %prec GE ( makeBinop(exp1,A.GeOp,exp2,GEleft) )
      

unaryop : MINUS exp (makeBinop(A.IntExp(0), A.MinusOp, exp, MINUSleft))

seqexp : LPAREN seqsexps RPAREN ( A.SeqExp(seqsexps) )

seqsexps : exp ( [(exp, expleft)] )
        | exp SEMICOLON seqsexps ( (exp,expleft)::seqsexps )
        | ([])

callexp : ID LPAREN callexpcon RPAREN (makeCallExp(ID,callexpcon,IDleft))

callexpcon : exp ([(exp,expleft)])
			| exp COMMA callexpcon ((exp,expleft)::callexpcon)
			| ([])

assignment : lvalue ASSIGN exp ( makeAssign( getLvalue(lvalue) , exp, ASSIGNleft) )

forexp : FOR ID ASSIGN exp TO exp DO exp (makeFor(ID, exp1, exp2, exp3, FORleft))

whileexp : WHILE exp DO exp ( makeWhile( exp1, exp2, WHILEleft) )

ifexp : IF exp THEN exp ( makeIf(exp1, exp2, (NONE), IFleft) )

ifelseexp : IF exp THEN exp ELSE exp ( makeIf(exp1, exp2, (SOME exp3), IFleft)  )

tydec : TYPE ID	EQ ty (A.IntExp(0))

ty : ID (A.IntExp(0))
	| arrty (A.IntExp(0))
	| recty (A.IntExp(0))

arrty : ARRAY OF ID (A.IntExp(0))

recty : LBRACE fielddeccontent RBRACE (A.IntExp(0))

fielddeccontent : fielddec (A.IntExp(0))
				| fielddec COMMA fielddeccontent (A.IntExp(0))
				| (A.IntExp(0))


fielddec : ID COLON ID (A.IntExp(0))

fundec : ID LPAREN fielddeccontent RPAREN EQ exp (A.IntExp(0))
		| ID LPAREN fielddeccontent RPAREN COLON ID EQ exp (A.IntExp(0))

vardec : ID ASSIGN exp (A.IntExp(0))
		| ID COLON ID ASSIGN exp (A.IntExp(0))

lvalue : ID ltail ( A.VarExp( makeLvalue(
			A.SimpleVar(S.symbol ID, IDleft), IDleft, ltail))
		  )

ltail : subscript ltail (subscript::ltail)
      | fieldexp ltail (fieldexp::ltail)
      | ([])

subscript : LBRACK exp RBRACK ((Subscript(exp), LBRACKleft))

fieldexp : DOT ID ((Field(S.symbol ID), DOTleft))

arrcreate : ID LBRACK exp RBRACK OF exp (A.IntExp(0))

reccreate : ID LBRACE reccreatecon RBRACE (A.IntExp(0))

reccreatecon : fieldcreate (A.IntExp(0))
			| fieldcreate COMMA reccreatecon (A.IntExp(0))
			| (A.IntExp(0))

fieldcreate : ID EQ exp (A.IntExp(0))

letexp : LET deccon IN seqsexps END (A.IntExp(0))

deccon : dec (A.IntExp(0))
		| dec deccon (A.IntExp(0))

dec : tydec (A.IntExp(0))
    | vardec (A.IntExp(0))
    | fundec (A.IntExp(0))


    (* [..missing rules for exp..] *)

(* [..missing rules for missing nonterminals..] *)
